'use strict';(function(){const indexCfg={};indexCfg.doc={id:'id',field:['title','content'],store:['title','href'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/docs/jvm/','title':"JVM",'content':"Java Virture Machine "});index.add({'id':1,'href':'/docs/jvm/parameter/','title':"JVM相关参数",'content':"记录一些JVM参数，以供参考\n   参数 说明     -XX:+/-UseTLAB 给对象分配内存空间时是否优先使用线程本地分配缓冲以解决在堆上分配时的竞争    "});index.add({'id':2,'href':'/docs/jvm/thread/without-toc/','title':"Without ToC",'content':"At me ipso nepotibus nunc celebratior genus Tanto oblite "});index.add({'id':3,'href':'/docs/java/','title':"Java",'content':"Java "});index.add({'id':4,'href':'/docs/jvm/thread/with-toc/','title':"With ToC",'content':"Caput vino delphine in tamen vias Cognita laeva illo fracta Natus quaerere Limitibus misere sit Enim sua Germana aves pignus tecta "});index.add({'id':5,'href':'/docs/jvm/heap/allocation/','title':"对象堆内存分配",'content':"对象堆内存分配 对象所需内存大小在类加载完成后便可完全确定，为对象分配空间的任务实际上便等同于把一块确定大小的内存从Java堆中划分出来。\n 分配方式：\n 指针碰撞 假设Java堆中内存是绝对规整的，所有被使用过的内存在一边，空闲的内存在另一边，中间有一个指针作为分界点，那分配内存时只需要移动一下这个指针即可。\n空闲列表 如果Java堆内存不规整，使用过的和没有使用过的内存交错在一起，虚拟机就必须维护一个列表，记录哪些内存是可用的其大小是多少。\n  选择哪一种分配方式由Java堆是否规整决定，而是否规整由所采用的垃圾收集器是否带有空间压缩整理决定。\n由于对象创建在虚拟机中是非常频繁的行为，即使仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的， 虚拟机采取的方案是：\n CAS + 失败重试 使用TLAB（Thread Local Allocation Buffer）来避免频繁的竞争，使用 XX:+UseTLAB来开启此功能  "});index.add({'id':6,'href':'/docs/jvm/gc/','title':"GC",'content':"垃圾收集器要完成的三件事：  哪些内存需要回收 何时回收 怎么回收  哪些内存需要回收  JVM通过可达性分析算法来判断对象是否存活 JVM通过一系列称为GC Root的根对象作为起始节点，根据引用关系搜索，来判断对象是否与Root节点可达。 如果不可达，则说明此对象不能再被使用，即可以被回收。\n GC Root对象包括：\n 虚拟机栈中引用的对象，譬如方法堆栈中的参数、局部变量、临时变量等(局部变量表?)； 本地方法栈中引用的对象； 方法区中的静态对象、常量对象； 线程对象； 据垃圾回收器的不同，GC Root也有不同的定义。   方法区也存在垃圾回收，主要回收：废弃的常量、不再使用的类型。\n 判定类型不再被使用的条件：\n Java堆中不存在该类及其任何子类的实例； 加载该类的类加载器已经卸载 该类对应的java.lang.Class对象没有被任何地方引用（包括反射）。  分代收集理论   弱分代假说：绝大多数对象都是朝生夕灭的 强分代假说：熬过多次垃圾收集的对象就越难以消亡   这两个假说共同奠定了多款常用的垃圾收集器一致的设计原则： 收集器应该将Java堆划分出不同的区域，然后依据对象的年龄分配到不同的区域中存储。 针对不同区域进行回收，以提高回收效率和内存空间的使用率。 针对不同区域存储对象的存亡特征使用不同的收集算法：\n 标记-复制 标记-清除 标记-整理  分代收集理论具体放到现在商用的Java虚拟机里，设计者一般至少会把Java堆划分为：\n 新生代 老年代    跨代引用假说：老年代和新生代会相互引用的情况占仅极少数 依据这条假说，不再为了少量的跨代引用去扫描整个老年代，只需在新生代上建立一个全局的记忆集，这个记忆集将老年代划分成若干小块，标识出老年代的哪一块内存存在跨代引用， 然后在发送MinorGC时，只有包含了跨代引用的小块内存里的对象才会被加入到GC ROOT中进行扫描。    MinorGC：指目标只是新生代垃圾收集； MajorGC：指目标只是老年代的垃圾收集；目前仅有CMS会有单独的收集老年代的行为； MixedGC：指目标是收集整个新生代以及部分老年代的垃圾收集；目前只有G1有这种行为； FullGC： 收集整个Java堆和方法区的垃圾收集；      GC 是否带压缩整理     Serial Y   ParNew Y   CMS N    "});index.add({'id':7,'href':'/docs/jvm/heap/','title':"Heap",'content':"堆\n"});index.add({'id':8,'href':'/docs/java/ref/','title':"Java引用",'content':"引用分类  强引用，普遍意义上的的引用，Object obj = new Object 软引用，用来描述一些还有用但非必须的对象，在系统将要发送内存溢出前（第一次垃圾回收后内存还是不够用时），会把这些对象加入回收范围进行二次回收。 SoftReference。 弱引用，用来描述一些非必须的对象，当垃圾回收发生时，无论当前内存是否足够，都会回收其关联的对象。WeakReference。 虚引用，其唯一的目的只是为了能在其关联的对象被回收时收到一个系统通知。 PhantomReference。  Finalizer 如果类重写了 finalize 方法，那么使用此类创建对象时，其新建的对象将被加入 java.lang.ref.Finalizer.unfinalized 队列。 如果此对象不可达，那么此对象将被放置在 java.lang.ref.Finalizer.queue队列，将由一个低优先级的线程在后台执行出队的Finalizer对象的runFinalizer方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  private void runFinalizer(JavaLangAccess jla) { synchronized (this) { // 是否已经执行过，执行过就不会再执行了，所以一个对象的finalize方法只会被执行一次  if (hasBeenFinalized()) return; // 从unfinalized对列  remove(); } try { Object finalizee = this.get(); if (finalizee != null \u0026amp;\u0026amp; !(finalizee instanceof java.lang.Enum)) { // 执行 finalize 方法。  jla.invokeFinalize(finalizee); finalizee = null; } } catch (Throwable x) { } super.clear(); }   TODO Reference 深入理解\n"});index.add({'id':9,'href':'/docs/jvm/thread/','title':"Thread",'content':"Ubi loqui "});index.add({'id':10,'href':'/posts/','title':"Blog",'content':""});index.add({'id':11,'href':'/posts/wangfugui/','title':"Wangfugui",'content':"难得的一次抓拍合影， 第一次献给王富贵。\n"});index.add({'id':12,'href':'/docs/','title':"Docs",'content':""});})();