'use strict';(function(){const indexCfg={};indexCfg.doc={id:'id',field:['title','content'],store:['title','href'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/docs/jvm/','title':"JVM",'content':"Java Virture Machine "});index.add({'id':1,'href':'/docs/jvm/parameter/','title':"JVM相关参数",'content':"记录一些JVM参数，以供参考\n   参数 说明     -XX:+/-UseTLAB 给对象分配内存空间时是否优先使用线程本地分配缓冲以解决在堆上分配时的竞争    "});index.add({'id':2,'href':'/docs/jvm/thread/without-toc/','title':"Without ToC",'content':"At me ipso nepotibus nunc celebratior genus Tanto oblite "});index.add({'id':3,'href':'/docs/java/','title':"Java",'content':"Java "});index.add({'id':4,'href':'/docs/jvm/thread/with-toc/','title':"With ToC",'content':"Caput vino delphine in tamen vias Cognita laeva illo fracta Natus quaerere Limitibus misere sit Enim sua Germana aves pignus tecta "});index.add({'id':5,'href':'/docs/jvm/heap/allocation/','title':"对象堆内存分配",'content':"对象堆内存分配 对象所需内存大小在类加载完成后便可完全确定，为对象分配空间的任务实际上便等同于把一块确定大小的内存从Java堆中划分出来。\n 分配方式：\n 指针碰撞 假设Java堆中内存是绝对规整的，所有被使用过的内存在一边，空闲的内存在另一边，中间有一个指针作为分界点，那分配内存时只需要移动一下这个指针即可。\n空闲列表 如果Java堆内存不规整，使用过的和没有使用过的内存交错在一起，虚拟机就必须维护一个列表，记录哪些内存是可用的其大小是多少。\n  选择哪一种分配方式由Java堆是否规整决定，而是否规整由所采用的垃圾收集器是否带有空间压缩整理决定。\n由于对象创建在虚拟机中是非常频繁的行为，即使仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的， 虚拟机采取的方案是：\n CAS + 失败重试 使用TLAB（Thread Local Allocation Buffer）来避免频繁的竞争，使用 XX:+UseTLAB来开启此功能  "});index.add({'id':6,'href':'/docs/jvm/gc/','title':"GC",'content':"   GC 是否带压缩整理     Serial Y   ParNew Y   CMS N    "});index.add({'id':7,'href':'/docs/jvm/heap/','title':"Heap",'content':"堆\n"});index.add({'id':8,'href':'/docs/jvm/thread/','title':"Thread",'content':"Ubi loqui "});index.add({'id':9,'href':'/posts/','title':"Blog",'content':""});index.add({'id':10,'href':'/posts/wangfugui/','title':"Wangfugui",'content':"难得的一次抓拍合影， 第一次献给王富贵。 "});index.add({'id':11,'href':'/docs/','title':"Docs",'content':""});})();