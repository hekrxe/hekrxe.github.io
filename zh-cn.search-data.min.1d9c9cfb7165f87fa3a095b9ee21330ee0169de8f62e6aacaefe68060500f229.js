'use strict';(function(){const indexCfg={};indexCfg.doc={id:'id',field:['title','content'],store:['title','href'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/docs/java/concurrent/cas/','title':"CAS",'content':"CAS(Compare And Swap)  不需要OS来执行上下文切换(系统调用)，而直接原子修改内存数据\n 底层汇编指令：\n1 2 3  // 如果是多处理器则加上 lock 指令 // 说明 cmpxchgl 不能保证原子性 IF_MP ? lock cmpxchgl : cmpxchgl;   lock 指令来保证原子性\n存在问题：1，ABA；2，CPU空跑\n"});index.add({'id':1,'href':'/docs/jvm/','title':"JVM",'content':"Java Virture Machine "});index.add({'id':2,'href':'/docs/jvm/parameter/','title':"JVM相关参数",'content':"记录一些JVM参数，以供参考\n - : 标准参数 -X : 非标准参数 -XX :     参数 说明     -XX:+/-UseTLAB 给对象分配内存空间时是否优先使用线程本地分配缓冲以解决在堆上分配时的竞争   -XX:+PrintFlagsFinal 打印JVM支持的参数   -XX:SurvivorRatio=8 新生代Eden区占80%    "});index.add({'id':3,'href':'/docs/jvm/gc/serial/','title':"Serial",'content':" 新生代单线程串行收集器，使用标记复制算法； 客户端模式下默认的新生代收集器。 对于内存受限的环境，内存占用是最小的；  -XX:+UseSerialGC\n"});index.add({'id':4,'href':'/docs/spring-boot/SpringApplication/','title':"SpringApplication",'content':"一切从一行代码看起\n1 2 3 4 5 6  @SpringBootApplication public class Main{ public static void main(String[] args) { SpringApplication.run(Main.class, args); } }   SpringBoot创建了一个 SpringApplication 对象，相关源码如下\n1 2 3 4 5 6 7  public SpringApplication(ResourceLoader resourceLoader, Class\u0026lt;?\u0026gt;... primarySources) { // ...  this.primarySources = new LinkedHashSet\u0026lt;\u0026gt;(Arrays.asList(primarySources)); setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class)); setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class)); this.mainApplicationClass = deduceMainApplicationClass(); }   保存的 primarySources 即是 我们的Main类的类对象。 SpringApplication 通过SPI的方式实例化了一批 ApplicationContextInitializer 的实现对象 和 ApplicationListener 对象。 同时 通过运行时栈确定了 启动类（main方法所在类）。\nrun 方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  public ConfigurableApplicationContext run(String... args) { SpringApplicationRunListeners listeners = getRunListeners(args); listeners.starting(); ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments); configureIgnoreBeanInfo(environment); context = createApplicationContext(); prepareContext(context, environment, listeners, applicationArguments, printedBanner); refreshContext(context); afterRefresh(context, applicationArguments); listeners.started(context); callRunners(context, applicationArguments); listeners.running(context); return context; }   SpringApplicationRunListeners 是一个用于执行 上文提到的 ApplicationListener 的一个包装对象，其内部有个事件广播器SimpleApplicationEventMulticaster, 即ApplicationListener的执行都是通过SimpleApplicationEventMulticaster 来广播的。\n创建一个环境对象ConfigurableEnvironment 并回调 SpringApplicationRunListeners 的 environmentPrepared方法，回调ApplicationListener通知ApplicationEnvironmentPreparedEvent事件到达。 创建一个ConfigurableApplicationContext对象，回调上文提到的 ApplicationContextInitializer的 initialize 方法。 刷新(refresh) ConfigurableApplicationContext。 回调 SpringApplicationRunListeners通知 ApplicationListener ApplicationStartedEvent事件到达。 回调 ApplicationRunner、CommandLineRunner 对象。 回调 ApplicationListener 通知 ApplicationReadyEvent事件。\n整体流程图如下： "});index.add({'id':5,'href':'/docs/java/concurrent/volatile/','title':"volatile",'content':"volatile的作用  -可见性 -禁止指令重排序\n 如何实现可见性  写,立即写到主内存 读,每次都到主内存读，言外之意：线程不会主动去主内存读取普通变量的值(第一次除外)  lock 实现\n如何禁止指令重排序 "});index.add({'id':6,'href':'/docs/jvm/thread/without-toc/','title':"Without ToC",'content':"At me ipso nepotibus nunc celebratior genus Tanto oblite "});index.add({'id':7,'href':'/docs/spring-boot/ApplicationListener/','title':"ApplicationListener",'content':"接上篇，先看看在SpringBoot启动的时候通过SPI的方式实例化了哪些 ApplicationListener,有11个,但本篇只研究以下几种\n ConfigFileApplicationListener LoggingApplicationListener BackgroundPreinitializer DelegatingApplicationListener   ConfigFileApplicationListener 其核心方法如下：\n1 2 3 4 5 6 7 8 9  @Override public void onApplicationEvent(ApplicationEvent event) { if (event instanceof ApplicationEnvironmentPreparedEvent) { onApplicationEnvironmentPreparedEvent((ApplicationEnvironmentPreparedEvent) event); } if (event instanceof ApplicationPreparedEvent) { onApplicationPreparedEvent(event); } }   从代码可以看出 它只关心两种类型的事件： ApplicationEnvironmentPreparedEvent 和 ApplicationPreparedEvent. 即在 ConfigurableEnvironment 对象创建出来后，和 应用程序加载完资源后被通知到。\n1 2 3 4 5 6 7 8  private void onApplicationEnvironmentPreparedEvent(ApplicationEnvironmentPreparedEvent event) { List\u0026lt;EnvironmentPostProcessor\u0026gt; postProcessors = loadPostProcessors(); postProcessors.add(this); AnnotationAwareOrderComparator.sort(postProcessors); for (EnvironmentPostProcessor postProcessor : postProcessors) { postProcessor.postProcessEnvironment(event.getEnvironment(), event.getSpringApplication()); } }   onApplicationEnvironmentPreparedEvent 方法主要是回调 EnvironmentPostProcessor后置处理器。 从代码实现上看，ConfigFileApplicationListener 也实现了 EnvironmentPostProcessor 接口，它主要是用来加载资源文件，加载到env，加载规则如下：\n 将 参数 spring.config.additional-location 指定的资源加载进来, 譬如  1  java -jar demo.jar -spring.config.additional-location=classpath:a.properties    加载 application.yml 或者 application.properties配置，如果参数 spring.config.location 被指定了，则从指定的位置加载文件，否则按以下规则查找并加载：classpath:/,classpath:/config/,file:./,file:./config/*/,file:./config/  另外一个事件是ApplicationPreparedEvent,即应用程序已经加载完成了所有资源文件，但是ctx还没有refresh操作之前的事件， 从源码上看，仅仅向ctx添加了一个 PropertySourceOrderingPostProcessor 处理器（BeanFactoryPostProcessor）。\n综上(具体细节还是打开源码文件一看便知，这里仅仅是梳理个脉络) ConfigFileApplicationListener主要作用就是读取应用的配置文件并添加到Environment里。\n扩展：其实我们真实的应用环境配置是比较复杂的，有些场景是在ctx refresh前就需要加载进来，则可以依据此来实现\n LoggingApplicationListener 有没有因为日志框架冲突而整天都在排包？有没有因为日志配置问题导致应用起不来？有没有日志打印不到指定的文件\u0026hellip; 业务量大、日志打印繁多、磁盘文件爆满？想在线上不重启的情况下临时修改日志级别来定位问题?等等类似一堆日志问题，相信头疼过的人不止我一个.\n以上，题外话\u0026hellip;.\n该监听器主要用来配置 LoggingSystem,如果在环境变量中配置了 logging.config属性， 则使用它指定的文件来引导LoggingSystem的配置；否则使用默认的配置。\n也就是说，在SpringBoot中，无论是 log4j、log4j2 还是logback,都被抽象成了 LoggingSystem。\n这给开发人员提了个醒：我们的一些譬如动态日志修改就可以通过这个 LoggingSystem 对象来完成。具体实现可以看看 LoggingSystem的API。\n（实际上，SpringBoot endpoint的动态日志管理就是通过这个对象来实现的）。\n BackgroundPreinitializer 用于初始化一些在第一次加载比较耗时的一些组件，实现原理是：启动了一个后台线程来挨个进行初始化。\n预热，预初始化。\n主要初始化的组件有:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  private void performPreinitialization() { Thread thread = new Thread(new Runnable() { @Override public void run() { runSafely(new ConversionServiceInitializer()); // javax.validation  runSafely(new ValidationInitializer()); // 消息转换器  runSafely(new MessageConverterInitializer()); // json  runSafely(new JacksonInitializer()); // 字符集  runSafely(new CharsetInitializer()); preinitializationComplete.countDown(); } }, \u0026#34;background-preinit\u0026#34;); thread.start(); }    DelegatingApplicationListener 处理用户自定义的 ApplicationListener\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  public void onApplicationEvent(ApplicationEvent event) { if (event instanceof ApplicationEnvironmentPreparedEvent) { List\u0026lt;ApplicationListener\u0026lt;ApplicationEvent\u0026gt;\u0026gt; delegates = getListeners( ((ApplicationEnvironmentPreparedEvent) event).getEnvironment()); if (delegates.isEmpty()) { return; } this.multicaster = new SimpleApplicationEventMulticaster(); for (ApplicationListener\u0026lt;ApplicationEvent\u0026gt; listener : delegates) { this.multicaster.addApplicationListener(listener); } } if (this.multicaster != null) { this.multicaster.multicastEvent(event); } }   实例化环境变量参数context.listener.classes指定的ApplicationListener，并回调对应的ApplicationEvent事件。 从源码可以看出，通过参数用户自定义的 ApplicationListener 只会收到 ApplicationEnvironmentPreparedEvent 事件以后发生的事件。 从上文可以知道，这些事件包括但不限于：ApplicationStartedEvent,ApplicationReadyEvent\u0026hellip;\n"});index.add({'id':8,'href':'/docs/java/','title':"Java",'content':"Java "});index.add({'id':9,'href':'/docs/jvm/gc/par_new/','title':"ParNew",'content':"ParNew实质上是Serial的多线程并行版本，除了同时使用多条线程进行垃圾收集之外，其余的行为都与Serial完全一致。 JDK7之前服务端模式下的新生代首选收集器。\n除了Serial之外，目前只有ParNew能与CMS配合使用。\nCMS是HotSpot在JDK1.5推出的第一款真正意义上的并发（Concurrent）收集器，第一次实现了让垃圾收集线程与用户线程（基本上）同时工作； CMS作为老年代收集器，但却无法与JDK1.4已经存在的新生代收集器Parallel Scavenge配合工作； 因为Parallel Scavenge（以及G1）都没有使用传统的GC收集器代码框架，而另外独立实现；而其余几种收集器则共用了部分的框架代码；\n -XX:+UseConcMarkSweepGC：指定使用CMS后，会默认使用ParNew作为新生代收集器； -XX:+UseParNewGC：指定使用ParNew；  -XX:ParallelGCThreads：指定垃圾收集的线程数量，ParNew默认开启的收集线程与CPU的数量相同；  JDK9开始，CMS+ParNew不再是官方推荐的组合\n"});index.add({'id':10,'href':'/docs/java/concurrent/synchronized/','title':"Synchronized",'content':"synchronized 不能保证代码块内的指令重排序。\n重量级锁  JVM对于OS来说是一个普通的进程，当JVM申请锁资源时必须通过上下文切换进入内核态(系统调用)才能申请到锁，因此通过这种方式(系统调用)获取的锁是重量级锁(开销大)。\n 轻量级锁  如果不经过内核态而获取的锁都可以叫做轻量级锁。\n 偏向锁 -\u0026gt; 轻量级锁(自旋锁CAS) -\u0026gt; 重量级锁\n偏向锁启动延时： -XX:BiasedLockingStartupDelay=4000 (因为如果一开始就启动，本身JVM就有很多sync代码，偏向、升级效率低；并发场景高的场景不应该打开，因为如果明知 某个对象会有很多线程在竞争，那么其效率反而下降)\n 自旋次数超过一定时间、自旋线程达到一定量、自适应自旋 后升级为重量级锁。  "});index.add({'id':11,'href':'/docs/jvm/thread/with-toc/','title':"With ToC",'content':"Caput vino delphine in tamen vias Cognita laeva illo fracta Natus quaerere Limitibus misere sit Enim sua Germana aves pignus tecta "});index.add({'id':12,'href':'/docs/jvm/heap/allocation/','title':"对象堆内存分配",'content':"对象堆内存分配 对象所需内存大小在类加载完成后便可完全确定，为对象分配空间的任务实际上便等同于把一块确定大小的内存从Java堆中划分出来。\n 分配方式：\n 指针碰撞 假设Java堆中内存是绝对规整的，所有被使用过的内存在一边，空闲的内存在另一边，中间有一个指针作为分界点，那分配内存时只需要移动一下这个指针即可。\n空闲列表 如果Java堆内存不规整，使用过的和没有使用过的内存交错在一起，虚拟机就必须维护一个列表，记录哪些内存是可用的其大小是多少。\n  选择哪一种分配方式由Java堆是否规整决定，而是否规整由所采用的垃圾收集器是否带有空间压缩整理决定。\n由于对象创建在虚拟机中是非常频繁的行为，即使仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的， 虚拟机采取的方案是：\n CAS + 失败重试 使用TLAB（Thread Local Allocation Buffer）来避免频繁的竞争，使用 XX:+UseTLAB来开启此功能  "});index.add({'id':13,'href':'/docs/spring-boot/ApplicationContextInitializer/','title':"ApplicationContextInitializer",'content':"ApplicationContextInitializer 的回调时间是：创建ApplicationContext后执行的。\n跟上篇一样，本篇仅聊几个感兴趣的。其实仔细去看SpringBoot通过SPI实例化的 ApplicationContextInitializer 基本上都只做了几件事：\n 代理用户通过参数context.initializer.classes自定义的ApplicationContextInitializer，DelegatingApplicationContextInitializer 干的就是这件事。 向Context中添加各种后置处理器，譬如ConfigurationWarningsApplicationContextInitializer添加的是 BeanDefinitionRegistryPostProcessor 向context中添加 ApplicationListener ，譬如RSocketPortInfoApplicationContextInitializer.  具体的 PostProcessor 和 ApplicationListener 后文再详细给出。\n"});index.add({'id':14,'href':'/docs/jvm/gc/parallel_scavenge/','title':"Parallel Scavenge",'content':"基于标记复制算法的并行多线程新生代收集器。\n其关注点是吞吐量，吞吐量优先收集器。\n自适应调节策略是ParallelScavenge的一个特点。\n -XX:MaxGCPauseMillis 控制其最大停顿时间 -XX:GCTimeRation 设置吞吐量大小（0-100）,设置 垃圾收集占用的时间。 -XX:UseAdaptiveSizePolicy,此参数被激活后，就不需要人工指定新生代大小、Eden与Survivor区的比率、 晋升老年代对象大小(-XX:PretenureSizeThreshold)等参数细节，虚拟机会根据当前系统的运行状态进行性能 监控来动态调整这些参数以提供合适的停顿时间和最大的吞吐量。  吞吐量=us/(us+sy)\n"});index.add({'id':15,'href':'/docs/spring-boot/','title':"Spring Boot",'content':"run:\nrefresh: 不断完善中\n"});index.add({'id':16,'href':'/docs/spring-boot/ApplicationContext/','title':"ApplicationContext",'content':"ApplicationContext 是一个为应用程序提供配置的核心接口。提供：\n 通过 Bean factory 方法访问应用程序组件；（继承自 ListableBeanFactory) 以通用的方式提供加载资源文件的能力；（继承自 ResourceLoader） 为注册的监听器提供事件发布的能力；（继承自 ApplicationEventPublisher) 支持国际化解析消息的能力.   AbstractApplicationContext 采用模板方法设计模式实现 ApplicationContext，其核心方法如下（不考虑异常情况）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  public void refresh() throws BeansException, IllegalStateException { // 告诉子类去刷新其内部的 BeanFactory ,并返回  ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // 使用当前上下文信息去配置 BeanFactory 的上下文信息  prepareBeanFactory(beanFactory); // 模板方法，允许子类去配置 BeanFactory  postProcessBeanFactory(beanFactory); // 到这一步，说明 BeanFactory 已经准备好了，那么找出所有的后置处理器 BeanFactoryPostProcessor 并回调他们  invokeBeanFactoryPostProcessors(beanFactory); // 从BeanFactory中获取（先实例化）所有的BeanPostProcessors，并添加到 BeanPostProcessors 列表  registerBeanPostProcessors(beanFactory); // 初始国际化组件  initMessageSource(); // 初始化事件广播器  initApplicationEventMulticaster(); // 模板方法,子类如果需要的话可以去做一些额外的操作，比如实例化WebServer  onRefresh(); // 将ApplicationListener注册到事件广播器上  registerListeners(); // 实例化所有的单例对象（non-lazy-init）  finishBeanFactoryInitialization(beanFactory); // 结束并回调LifecycleProcessor,触发 ContextRefreshedEvent 事件  finishRefresh(); }   其核心设计流程大致如下图： 啊\n"});index.add({'id':17,'href':'/docs/spring-boot/BeanFactory/','title':"BeanFactory",'content':"BeanFactory\n"});index.add({'id':18,'href':'/docs/jvm/gc/serial_old/','title':"Serial Old",'content':"Serial Old是Serial的老年代版本， 单线程串行收集器，采用 标记-整理 算法。\n两种用途：\n JDK5以前与ParallelScavenge配合使用 作为CMS发生失败的时候的后备方案。  "});index.add({'id':19,'href':'/docs/jvm/gc/parallel_old/','title':"Parallel Old",'content':"Parallel Old是Parallel Scavenge的老年代版本。\n支持多线程并发，基于标记整理算法。\n在优先考虑吞吐量的场景可以使用 ParallelScavenge作为新生代收集器ParallelOld作为老年代收集器的组合。\n"});index.add({'id':20,'href':'/docs/jvm/gc/cms/','title':"CMS",'content':"CMS是一种以获取最短回收停顿时间为目标的收集器。 基于标记清除算法。\n运行主要分为四步：\n 初始标记 - stop the world 并发标记 重新标记 - stop the world 并发清除  初始标记，仅仅只是标记一下GC Root能直接关联到的对象，速度快。\n并发标记，从GCRoot的直接关联的对象开始遍历整个对象图，这个过程耗时长但不需要暂停用户线程。\n重新标记，则是为了修正并发标记阶段因用户线程导致标记变动的那一部分对象。\n并发清除，清理删除掉标记阶段判断依据死亡的对象，不需要移动对象，可与用户线程并发执行。\n优点：\n 并发收集、低停顿。\n 缺点：\n 并发标记、并发清除过程占用线程（占用处理器时间）而降低总吞吐量。 无法处理浮动垃圾，在并发标记、并发清除阶段，用户线程可能会产生新的垃圾（比如标记结束后产生的垃圾）；基于这个原因，CMS必须预留一部分内存给用户线程以便有足够的内存可分配给新对象。基于此，CMS在并发失败（CMS运行期间没有内存分配给新对象）的时候就不得不进行一次空间整理（此过程需暂停用户线程，采用SerialOld算法实现）。 由于是采用标记-清除算法，意味着收集结束后会产生大量的空间碎片。导致当需要分配大对象时没有足够的空间而不得不提前触发一次FullGC.\n "});index.add({'id':21,'href':'/docs/jvm/gc/g1/','title':"G1",'content':"G1是面向全堆的垃圾收集器，不再需要其他新生代收集器的配合工作。\nG1开创了面向局部收集的设计思路和基于Region的内存布局形式。\n支持 类型卸载。\nJDK9成为服务端模式下的默认垃圾收集器，CMS则被声明为不推荐使用。\nG1可以面向堆内存任何部分来组成回收集进行回收，衡量标椎不再是它属于哪个分代，而是哪块内存中存放大垃圾数量最多，回收收益最大，这就是G1收集器的MixedGC模式。\nG1开创的基于Region的堆内存布局是它能够实现这个目标的关键。\n虽然G1也遵循分代收集理论的设计，但其堆内存的布局与其他收集器有非常明显的差异： G1不再坚持固定大小以及固定数量的分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域，每个Region都可以根据需要,扮演新生代新生代或老年代。 换言之，新生代、老年代 都是一系列区域(Region,不需要连续)的动态集合。 收集器能对不同角色的Region采用不同的策略去处理，这样无论是信创建的对象还是已经存活了一段时间的旧对象都能获得很好的手机效果。 Region中还有一类特殊的Humongous区域，专门用来存储大对象。\nRegion大小可通过 -XX:G1HeapRegionSize 设定，取值范围1MB~32MB,超过Region大小一半的对象即可判定为大对象。\nG1之所以能建立起 可预测的停顿时间 模型，是因为它将Region作为单次回收的最小单元，这样可以有计划地避免在整个Java堆中进行全区域的收集。 更具体的处理思路是：让G1收集器去跟踪各个Region里面的垃圾堆积的价值大小，然后在后台维护一个优先级列表，每次根据用户设定的允许收集停顿的时间，优先处理回收价值收益最大的那些Region。\n参数 -XX:MaxGCPauseMillis指定最大停顿时间，默认200ms.\n几个需解决的问题：\n跨Region引用 使用记忆集避免全堆扫描，每个Region都维护自己的记忆集，比前面介绍的卡表更复杂（不仅仅记录了 谁指向我 还记录了 我指向谁）。\n搜索对象图的时候（并发标记过程）如何保证收集线程与用户线程互不干扰地运行 CMS采用增量更新算法实现，G1则是采用原始快照（SATB）来实现。\n另外，在收集时，如何避免不影响用户线程分配新对象？G1为每个Region设置了两个名为TAMS（Top At Mark Start）的指针，把Region中的一部分空间划分出来用于并发回收过程中的新对象分配。\n简言之，回收线程在回收Region时默认划分出来的那一个内存内的对象是存活的，不纳入回收范围。\n如果回收速度赶不上分配速度，G1也要被迫冻结用户线程，而不得不执行FullGC,而产生长时间的 Stop the World.\n如何实现 可预测模型 G1以 衰减均值 为理论基础来实现的，在垃圾收集过程中，G1收集器会记录每个Region的回收耗时、记忆集里的脏卡数据量等各个可测量的步骤花费的成本，并分析得出平均值、标准偏差、置信度等统计信息。 然后根据这些信息预测现在开始回收的话，由哪些Region组成回收集才可以在不超过期望停顿时间的约束下获得最高收益。\nG1收集器的运作过程：\n 初始标记，标记GCRoot能直接关联的对象，并修改TAMS指针，让下一阶段用户线程并发运行时能正确地在可用的Region中分配新对象。这个阶段需要停顿线程，但耗时短，且是借用MinorGC的时候完成的。 并发标记，从GCRoot开始对堆中对象进行可达性分析，递归扫描整个堆中的对象图，找出要回收的对象，这个阶段耗时长，但可与用户线程并发执行，并发执行完之后需要重新处理SATB记录下的在并发时有引用变动的对象。 最终标记，对用户线程作一个短暂的暂停，用于处理并发阶段结束后仍遗留下来的最后那些少量的SATB记录。 筛选回收，负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划。可以自由选择任意多个Region构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region，再清理掉整个Region的全部空间。此过程牵扯到移动对象，必须暂停用户线程由多个线程完成。  除了并发标记阶段，其余过程都需要暂停用户线程，它并非纯粹地追求低延迟，官方给它设定的 目标是在延迟可控的情况下获得尽可能高的吞吐量。\n从G1开始，垃圾收集器的设计导向不约而同地变为：应用的内存分配速率小于收集速率为方向，而不是一次性清理掉整个堆。 即，应用在分配内存，收集器同时在回收内存，只要收集器的速度赶得上对象分配速率 就很完美了。\n优缺点：\n 从整体上看，G1基于标记-整理算法，从region来看是基于标记-复制算法，不会产生内存碎片。 可指定最大停顿时间、分Region的内存布局、按收益动态确定回收集。 内存占用高（记忆集、统计数据等） 负载高（与用户线程并发执行，维护记忆集、原始快照算法的实现（写前屏障、写后屏障都使用了））  衡量垃圾收集器的重要指标：\n 内存占用 吞吐量 延迟  "});index.add({'id':22,'href':'/docs/jvm/gc/','title':"GC",'content':"垃圾收集器要完成的三件事：  哪些内存需要回收 何时回收 怎么回收  哪些内存需要回收  JVM通过可达性分析算法来判断对象是否存活 JVM通过一系列称为GC Root的根对象作为起始节点，根据引用关系搜索，来判断对象是否与Root节点可达。 如果不可达，则说明此对象不能再被使用，即可以被回收。\n GC Root对象包括：\n 虚拟机栈中引用的对象，譬如方法堆栈中的参数、局部变量、临时变量等(局部变量表?)； 本地方法栈中引用的对象； 方法区中的静态对象、常量对象； 线程对象； 据垃圾回收器的不同，GC Root也有不同的定义。   方法区也存在垃圾回收，主要回收：废弃的常量、不再使用的类型。\n 判定类型不再被使用的条件：\n Java堆中不存在该类及其任何子类的实例； 加载该类的类加载器已经卸载 该类对应的java.lang.Class对象没有被任何地方引用（包括反射）。  分代收集理论   弱分代假说：绝大多数对象都是朝生夕灭的 强分代假说：熬过多次垃圾收集的对象就越难以消亡   这两个假说共同奠定了多款常用的垃圾收集器一致的设计原则： 收集器应该将Java堆划分出不同的区域，然后依据对象的年龄分配到不同的区域中存储。 针对不同区域进行回收，以提高回收效率和内存空间的使用率。 针对不同区域存储对象的存亡特征使用不同的收集算法：\n 标记-复制 标记-清除 标记-整理  收集算法主要关注：\n 回收时间 \u0026mdash; 停顿问题 内存碎片 \u0026mdash; 吞吐问题  分代收集理论具体放到现在商用的Java虚拟机里，设计者一般至少会把Java堆划分为：\n 新生代 老年代    跨代引用假说：老年代和新生代会相互引用的情况占仅极少数 依据这条假说，不再为了少量的跨代引用去扫描整个老年代，只需在新生代上建立一个全局的记忆集，这个记忆集将老年代划分成若干小块，标识出老年代的哪一块内存存在跨代引用， 然后在发送MinorGC时，只有包含了跨代引用的小块内存里的对象才会被加入到GC ROOT中进行扫描。    MinorGC：指目标只是新生代垃圾收集； MajorGC：指目标只是老年代的垃圾收集；目前仅有CMS会有单独的收集老年代的行为； MixedGC：指目标是收集整个新生代以及部分老年代的垃圾收集；目前只有G1有这种行为； FullGC： 收集整个Java堆和方法区的垃圾收集；   标记-清除 算法  分为标记和清除两个阶段：首先标记出需要回收的对象，在标记完成后，统一回收对象（即可回收标记的也可回收未标记的对象，具体算法具体分析）\n 存在的缺点：\n 执行效率不稳定，假如需要回收大量对象，这时就必须进行大量的标记和清除动作； 存在内存空间碎片问题，在标记清除之后会产生大量的不连续的内存碎片，碎片太多可能导致当分配大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集。  不需要移动对象\n适合清除对象少、分配对象空间频率低的场景，譬如CMS的老年代也采用了这种算法作为一部分收集过程(配合整理算法)。\n标记-复制 算法  算法思想： 将内存分为大小相等的两块，每次只使用其中一块；当使用的那一块使用完了，就将存活对象复制到另一块上面，然后再把已使用内存空间一次清理掉。\n 缺点：\n 如果存在大量存活对象，那么将产生大量的内存空间复制的开销。反之就是它的优点。 空间浪费，只有一半的空间可被使用。  优点：\n 不存在空间碎片问题，分配内存时只需移动堆顶指针即可，实现简单、运行高效。  一般现在商用的虚拟机优先采用这种算法来回收新生代(存活对象少，只需很小的复制开销)，只不过内存空间不是1：1的比率， 而是将新生代划分为 8:1:1 的三块空间，名字叫，Eden:SurvivorFrom:SurvivorTo,每次只使用Eden和其中一块Survivor空间， 当垃圾回收发生时，将Eden和SurvivorFrom中存活的对象复制到SurvivorTo上面。 此算法的空间利用率是 90%。 不过存在被复制到的Survivor空间不足的情况，这时就需要其它空间（一般就是老年代）来进行分配担保。\n适合存活对象少的场景，比如年轻代。\n标记-整理 算法  一般在老年代采用这种算法（老年代没有空间担保机制，且其对象存活率较高），其算法思想是： 先标记出要回收的或不需要回收的对象，然后将所有存活的对象往空间一端移动，然后直接清理掉边界以外的空间。\n 移动存活对象需要全程暂停用户应用程序才能进行。\n移动对象则内存回收更复杂（暂停用户程序）； 不移动对象则内存分配更复杂(内存碎片问题)。\n从停顿时间来看： 不移动对象停顿时间短甚至不需要停顿，但吞吐量将下降(存在空间碎片，只能使用空闲列表算法，所以分配内存慢)；移动对象则反之。\n所以，需要看你是在意吞吐量还是停顿。\n另外，还有一种\u0026rsquo;混合\u0026rsquo;方案，平时就采用 标记-清除 算法，当空间碎片化程度大到已经影响对象分配时再采用 标记-整理 算法。CMS就是这么干的。\n据以上，不同场景采用不同的算法就衍生出了各种垃圾回收器。\n 根节点枚举  固定可作为GC Root的节点主要在全局性的引用与执行上下文中。 迄今为止，所有收集器在根节点枚举这一步都是必须暂停用户线程的（Stop The World）. 当用户线程停顿下来后，JVM通过OopMap这个结构来查找到根节点，而不需要真正一个不漏地从堆或方法区开始查找。\n 安全点  因为用户线程在执行的过程中会随时修改对象间的引用关系，因此，在根节点枚举时必须使用户线程停下来。 用户线程停顿，是有前提的，并不是随时随地都可以停下来，只有在一些特殊的点可以停顿下来，这些点被称作 安全点。 安全点不能太少，以致让收集器等待太长时间，也不能太多以致增大运行时的内存负荷（OopMap).\n 安全点的选取：是否具有让程序长时间执行的特征，比如方法调用、循环跳转、异常跳转等指令，只有具备这些功能的指令才会产生安全点。\n用户线程主动在安全点中断而停下来。（当垃圾收集需要中断线程时，设置一个标志位，各个用户线程执行过程中主动轮询这个标志，一旦标志被打开就自己在最近的安全点上主动中断挂起）\n安全区域  安全点机制保证了程序执行时，在不太长的时间内就会遇到可进入垃圾收集过程的安全点； 但是，程序不执行的时候就行不通了（Sleep、Blocked），这时线程无法中断。 安全区域是指，能够确保在某一段代码片段中，引用关系不会发生变化，因此在这个区域中任意地方开始垃圾收集都是安全的。\n 当用户线程进入安全区域时，首先会标识自己已经进入了安全区域，那样当这段时间里虚拟机发起垃圾收集时就不必去管这些已经声明在安全区域的线程了； 当用户线程要离开安全区域时，它要检测虚拟机当前是否正在执行根节点枚举，如果完成了，那线程当作什么事也没发生继续执行，否则就必须一直等待直到收到可以离开安全区域的信号为止。\n记忆集与卡表  为了解决对象跨代引用所带来的问题，垃圾收集器在新生代建立名为 记忆集 的数据结构，用以避免将整个老年代加进GC Root的扫描范围。 事实上，并不是只有年轻代、老年代之间才有跨代引用的问题，所有涉及部分区域收集行为的垃圾收集器都会面临同样的问题（G1、ZGC）。\n 记忆集是一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构。\n卡表  卡表是记忆集的一种实现方式，它定义了记忆集的记录精度、与堆内存的映射关系。 HotSpot的实现采用了 字节数组 来实现（有点BitMap的意思）。\n 字节数组中的每一个元素(一字节)都对应着其标识的内存区域中一块特定大小的内存块，这个内存块被称作 卡页（Card Page). 一般来说，卡页的大小是2的n次幂的字节数，HotSpot是512字节(2^9).\n一个卡页的内存中通常包含不止一个对象，只要卡页内有一个对象的字段存在跨代引用，那其对应的卡表的数组元素被标识为1，称这个元素变脏（Dirty）。\n在根节点枚举时，只要筛选出卡表中变脏的元素，就能轻易得出哪些卡页内存中包含跨代指针，把他们加入GC Root中一并扫描。\n写屏障 在HotSpot虚拟机中，通过写屏障来维护卡表状态。 写屏障可以看作 引用类型字段赋值 这个动作的一个AOP切面。 在引用对象赋值时会产生一个环形(Around)通知,供程序执行额外的动作，也就是说赋值的前后都在写屏障的覆盖范围内。 在赋值前的叫做 写前屏障，在赋值后的叫做 写后屏障。\n卡表在高并发场景下还面临着 伪共享 问题(卡表是一个字节数组)。\n因此，在应用写后屏障后，卡表的实现是：先检测卡表标记，如果未被标记才去标记：\n1 2  // 类似这样 if(CardTable[i] != 1) CardTable[i] = 1;   以上解决了GC Root枚举的理论问题。\n 可达性分析  可达性分析算法理论上要求全过程都基于一个能保障一致性的快照中才能进行分析，这意味着全程必须暂停用户线程。 在根几点枚举过程中，GCRoot对象相比整个堆对象来说还算是极少数的，但是从GCRoot再继续遍历对象时，那停顿时间太长了。\n 想解决解决或降低用户线程暂停时间，就要搞清楚为什么必须在一个能保障一致性的快照上才能进行对象图的遍历？ 为了能解释清楚，引入三色标记 作为工具来辅助推导。 把遍历对象图的过程中遇到的对象按照 是否访问过 这个条件，将对象标记为以下三种颜色：\n 白色： 表示对象尚未被垃圾收集器访问过。显然，在可达性分析刚刚开始时，所有对象都是白色的，若在分析结束后对象仍然是白色的，则说明此对象不可达。 黑色： 表示对象已经被访问过，且这个对象的所有引用都已经扫描过。此颜色的对象是安全存活的，如果有其他对象指向了黑色对象，则无需再扫描一遍（被指向的黑色对象无需再扫描）。 灰色： 表示对象已经被垃圾收集器访问过，但这个对象上至少存在一个引用还没被扫描过。  在可达性分析扫描的过程中，如果用户线程是暂停的，那么此种算法不存在问题； 但如果用户线程和GC线程同时运行呢，就存在用户线程在修改引用关系的可能，这就会出现两种结果： 1，把原本消亡的对象标记为存活，这还可以忍受，大不了下次收集时再扫描一遍。 2，把原本存活的对象标记为死亡，这是不可容忍的。\n当且仅当满足以下两个条件时，黑色对象会被误标记为白色（即应该存活的对象被标记为了不可达对象）。\n 赋值器插入了一条或多条从黑色对象到白色对象的新引用（黑色对象表示其引用的所有对象都存活，若此白色对象一定存活，那就是本该黑色的对象却是白色的了，言外之意是该白色对象尚未被访问过，却被认为已经访问过了）； 赋值器删除了全部从灰色对象到该白色对象的直接或间接引用（说明被删的白色对象不会再被访问，这些对象中存在黑色对象却被误标记为了白色）。  因此，需要破坏这两个条件的其中之一即可：\n 增量更新，破坏第一个 原始快照，破坏第二个  增量更新  当黑色对象插入新的指向白色对象的引用关系时，就将这个新插入的引用记录下来，等并发扫描结束之后，再将这些记录过的引用引用关系中的黑色对象为根重新再扫描一次。\n 原始快照  当灰色对象要删除指向白色对象的引用关系时，就将这个要删除的引用记录下来，在并发扫描结束之后，再将这些记录过的引用关系中的灰色对象作为根，重新扫描一次。\n 以上，无论是对引用关系记录的插入还是删除，虚拟机的记录操作都是通过写屏障实现的。\nCMS基于增量更新,G1则是基于原始快照 来破坏误标记的条件。\n    GC 是否带压缩整理     Serial Y   ParNew Y   CMS N    "});index.add({'id':23,'href':'/docs/jvm/heap/','title':"Heap",'content':"堆\n"});index.add({'id':24,'href':'/docs/java/ref/','title':"Java引用",'content':"引用分类  强引用，普遍意义上的的引用，Object obj = new Object 软引用，用来描述一些还有用但非必须的对象，在系统将要发送内存溢出前（第一次垃圾回收后内存还是不够用时），会把这些对象加入回收范围进行二次回收。 SoftReference。 弱引用，用来描述一些非必须的对象，当垃圾回收发生时，无论当前内存是否足够，都会回收其关联的对象。WeakReference。 虚引用，其唯一的目的只是为了能在其关联的对象被回收时收到一个系统通知。 PhantomReference。  Finalizer 如果类重写了 finalize 方法，那么使用此类创建对象时，其新建的对象将被加入 java.lang.ref.Finalizer.unfinalized 队列。 如果此对象不可达，那么此对象将被放置在 java.lang.ref.Finalizer.queue队列，将由一个低优先级的线程在后台执行出队的Finalizer对象的runFinalizer方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  private void runFinalizer(JavaLangAccess jla) { synchronized (this) { // 是否已经执行过，执行过就不会再执行了，所以一个对象的finalize方法只会被执行一次  if (hasBeenFinalized()) return; // 从unfinalized对列  remove(); } try { Object finalizee = this.get(); if (finalizee != null \u0026amp;\u0026amp; !(finalizee instanceof java.lang.Enum)) { // 执行 finalize 方法。  jla.invokeFinalize(finalizee); finalizee = null; } } catch (Throwable x) { } super.clear(); }   TODO Reference 深入理解\n"});index.add({'id':25,'href':'/docs/jvm/thread/','title':"Thread",'content':"Ubi loqui "});index.add({'id':26,'href':'/docs/java/concurrent/','title':"并发",'content':"缓存一致性协议（MESI，MSI，MOSI，。。。）   cache line：64Byte，一次读取64Byte到缓存。 将每一个 cache line 标记为四种状态: Modified、Exclusive、Shared、Invalid，(MESI)。MESI的实现即是CPU们对这四种状态的协调处理 伪共享 缓存行对齐   "});index.add({'id':27,'href':'/posts/','title':"Blog",'content':""});index.add({'id':28,'href':'/posts/whkl/','title':"Whkl",'content':"对酒当歌的夜\n四下无人的街\n a stupid mistake\n"});index.add({'id':29,'href':'/posts/wangfugui/','title':"Wangfugui",'content':"难得的一次抓拍合影， 第一次献给王富贵。\n"});index.add({'id':30,'href':'/docs/','title':"Docs",'content':""});})();