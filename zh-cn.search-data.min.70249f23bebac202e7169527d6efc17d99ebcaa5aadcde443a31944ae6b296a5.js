'use strict';(function(){const indexCfg={};indexCfg.doc={id:'id',field:['title','content'],store:['title','href'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/docs/java/concurrent/cas/','title':"CAS",'content':"CAS(Compare And Swap)  不需要OS来执行上下文切换(系统调用)，而直接原子修改内存数据\n 底层汇编指令：\n1 2 3  // 如果是多处理器则加上 lock 指令 // 说明 cmpxchgl 不能保证原子性 IF_MP ? lock cmpxchgl : cmpxchgl;   lock 指令来保证原子性\n存在问题：1，ABA；2，CPU空跑\n"});index.add({'id':1,'href':'/docs/jvm/','title':"JVM",'content':"Java Virture Machine "});index.add({'id':2,'href':'/docs/jvm/parameter/','title':"JVM相关参数",'content':"记录一些JVM参数，以供参考\n - : 标准参数 -X : 非标准参数 -XX :     参数 说明     -XX:+/-UseTLAB 给对象分配内存空间时是否优先使用线程本地分配缓冲以解决在堆上分配时的竞争   -XX:+PrintFlagsFinal 打印JVM支持的参数    "});index.add({'id':3,'href':'/docs/java/concurrent/volatile/','title':"volatile",'content':"volatile的作用  -可见性 -禁止指令重排序\n 如何实现可见性  写,立即写到主内存 读,每次都到主内存读，言外之意：线程不会主动去主内存读取普通变量的值(第一次除外)  lock 实现\n如何禁止指令重排序 "});index.add({'id':4,'href':'/docs/jvm/thread/without-toc/','title':"Without ToC",'content':"At me ipso nepotibus nunc celebratior genus Tanto oblite "});index.add({'id':5,'href':'/docs/java/','title':"Java",'content':"Java "});index.add({'id':6,'href':'/docs/java/concurrent/synchronized/','title':"Synchronized",'content':"synchronized 不能保证代码块内的指令重排序。\n重量级锁  JVM对于OS来说是一个普通的进程，当JVM申请锁资源时必须通过上下文切换进入内核态(系统调用)才能申请到锁，因此通过这种方式(系统调用)获取的锁是重量级锁(开销大)。\n 轻量级锁  如果不经过内核态而获取的锁都可以叫做轻量级锁。\n 偏向锁 -\u0026gt; 轻量级锁(自旋锁CAS) -\u0026gt; 重量级锁\n偏向锁启动延时： -XX:BiasedLockingStartupDelay=4000 (因为如果一开始就启动，本身JVM就有很多sync代码，偏向、升级效率低；并发场景高的场景不应该打开，因为如果明知 某个对象会有很多线程在竞争，那么其效率反而下降)\n 自旋次数超过一定时间、自旋线程达到一定量、自适应自旋 后升级为重量级锁。  "});index.add({'id':7,'href':'/docs/jvm/thread/with-toc/','title':"With ToC",'content':"Caput vino delphine in tamen vias Cognita laeva illo fracta Natus quaerere Limitibus misere sit Enim sua Germana aves pignus tecta "});index.add({'id':8,'href':'/docs/jvm/heap/allocation/','title':"对象堆内存分配",'content':"对象堆内存分配 对象所需内存大小在类加载完成后便可完全确定，为对象分配空间的任务实际上便等同于把一块确定大小的内存从Java堆中划分出来。\n 分配方式：\n 指针碰撞 假设Java堆中内存是绝对规整的，所有被使用过的内存在一边，空闲的内存在另一边，中间有一个指针作为分界点，那分配内存时只需要移动一下这个指针即可。\n空闲列表 如果Java堆内存不规整，使用过的和没有使用过的内存交错在一起，虚拟机就必须维护一个列表，记录哪些内存是可用的其大小是多少。\n  选择哪一种分配方式由Java堆是否规整决定，而是否规整由所采用的垃圾收集器是否带有空间压缩整理决定。\n由于对象创建在虚拟机中是非常频繁的行为，即使仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的， 虚拟机采取的方案是：\n CAS + 失败重试 使用TLAB（Thread Local Allocation Buffer）来避免频繁的竞争，使用 XX:+UseTLAB来开启此功能  "});index.add({'id':9,'href':'/docs/jvm/gc/','title':"GC",'content':"垃圾收集器要完成的三件事：  哪些内存需要回收 何时回收 怎么回收  哪些内存需要回收  JVM通过可达性分析算法来判断对象是否存活 JVM通过一系列称为GC Root的根对象作为起始节点，根据引用关系搜索，来判断对象是否与Root节点可达。 如果不可达，则说明此对象不能再被使用，即可以被回收。\n GC Root对象包括：\n 虚拟机栈中引用的对象，譬如方法堆栈中的参数、局部变量、临时变量等(局部变量表?)； 本地方法栈中引用的对象； 方法区中的静态对象、常量对象； 线程对象； 据垃圾回收器的不同，GC Root也有不同的定义。   方法区也存在垃圾回收，主要回收：废弃的常量、不再使用的类型。\n 判定类型不再被使用的条件：\n Java堆中不存在该类及其任何子类的实例； 加载该类的类加载器已经卸载 该类对应的java.lang.Class对象没有被任何地方引用（包括反射）。  分代收集理论   弱分代假说：绝大多数对象都是朝生夕灭的 强分代假说：熬过多次垃圾收集的对象就越难以消亡   这两个假说共同奠定了多款常用的垃圾收集器一致的设计原则： 收集器应该将Java堆划分出不同的区域，然后依据对象的年龄分配到不同的区域中存储。 针对不同区域进行回收，以提高回收效率和内存空间的使用率。 针对不同区域存储对象的存亡特征使用不同的收集算法：\n 标记-复制 标记-清除 标记-整理  分代收集理论具体放到现在商用的Java虚拟机里，设计者一般至少会把Java堆划分为：\n 新生代 老年代    跨代引用假说：老年代和新生代会相互引用的情况占仅极少数 依据这条假说，不再为了少量的跨代引用去扫描整个老年代，只需在新生代上建立一个全局的记忆集，这个记忆集将老年代划分成若干小块，标识出老年代的哪一块内存存在跨代引用， 然后在发送MinorGC时，只有包含了跨代引用的小块内存里的对象才会被加入到GC ROOT中进行扫描。    MinorGC：指目标只是新生代垃圾收集； MajorGC：指目标只是老年代的垃圾收集；目前仅有CMS会有单独的收集老年代的行为； MixedGC：指目标是收集整个新生代以及部分老年代的垃圾收集；目前只有G1有这种行为； FullGC： 收集整个Java堆和方法区的垃圾收集；  标记-清除 算法  分为标记和清除两个阶段：首先标记出需要回收的对象，在标记完成后，统一回收对象（即可回收标记的也可回收未标记的对象，具体算法具体分析）\n 存在的缺点：\n 执行效率不稳定，假如需要回收大量对象，这时就必须进行大量的标记和清除动作； 存在内存空间碎片问题，在标记清除之后会产生大量的不连续的内存碎片，碎片太多可能导致当分配大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集。  标记-复制 算法  算法思想： 将内存分为大小相等的两块，每次只使用其中一块；当使用的那一块使用完了，就将存活对象复制到另一块上面，然后再把已使用内存空间一次清理掉。\n 缺点：\n 如果存在大量存活对象，那么将产生大量的内存空间复制的开销。反之就是它的优点。 空间浪费，只有一半的空间可被使用。  优点：\n 不存在空间碎片问题，分配内存时只需移动堆顶指针即可，实现简单、运行高效。  一般现在商用的虚拟机优先采用这种算法来回收新生代(存活对象少，只需很小的复制开销)，只不过内存空间不是1：1的比率， 而是将新生代划分为 8:1:1 的三块空间，名字叫，Eden:SurvivorFrom:SurvivorTo,每次只使用Eden和其中一块Survivor空间， 当垃圾回收发生时，将Eden和SurvivorFrom中存活的对象复制到SurvivorTo上面。 此算法的空间利用率是 90%。 不过存在被复制到的Survivor空间不足的情况，这时就需要其它空间（一般就是老年代）来进行分配担保。\n标记-整理 算法  一般在老年代采用这种算法（老年代没有空间担保机制，且其对象存活率较高），其算法思想是： 先标记出要回收的或不需要回收的对象，然后将所有存活的对象往空间一端移动，然后直接清理掉边界以外的空间。\n 移动存活对象需要全程暂停用户应用程序才能进行。\n移动对象则内存回收更复杂（暂停用户程序）； 不移动对象则内存分配更复杂(内存碎片问题)。\n从停顿时间来看： 不移动对象停顿时间短甚至不需要停顿，但吞吐量将下降(存在空间碎片，只能使用空闲列表算法，所以分配内存慢)；移动对象则反之。\n所以，需要看你是在意吞吐量还是停顿。\n另外，还有一种\u0026rsquo;混合\u0026rsquo;方案，平时就采用 标记-清除 算法，当空间碎片化程度大到已经影响对象分配时再采用 标记-整理 算法。CMS就是这么干的。\n据以上，不同场景采用不同的算法就衍生出了各种垃圾回收器。\n    GC 是否带压缩整理     Serial Y   ParNew Y   CMS N    "});index.add({'id':10,'href':'/docs/jvm/heap/','title':"Heap",'content':"堆\n"});index.add({'id':11,'href':'/docs/java/ref/','title':"Java引用",'content':"引用分类  强引用，普遍意义上的的引用，Object obj = new Object 软引用，用来描述一些还有用但非必须的对象，在系统将要发送内存溢出前（第一次垃圾回收后内存还是不够用时），会把这些对象加入回收范围进行二次回收。 SoftReference。 弱引用，用来描述一些非必须的对象，当垃圾回收发生时，无论当前内存是否足够，都会回收其关联的对象。WeakReference。 虚引用，其唯一的目的只是为了能在其关联的对象被回收时收到一个系统通知。 PhantomReference。  Finalizer 如果类重写了 finalize 方法，那么使用此类创建对象时，其新建的对象将被加入 java.lang.ref.Finalizer.unfinalized 队列。 如果此对象不可达，那么此对象将被放置在 java.lang.ref.Finalizer.queue队列，将由一个低优先级的线程在后台执行出队的Finalizer对象的runFinalizer方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  private void runFinalizer(JavaLangAccess jla) { synchronized (this) { // 是否已经执行过，执行过就不会再执行了，所以一个对象的finalize方法只会被执行一次  if (hasBeenFinalized()) return; // 从unfinalized对列  remove(); } try { Object finalizee = this.get(); if (finalizee != null \u0026amp;\u0026amp; !(finalizee instanceof java.lang.Enum)) { // 执行 finalize 方法。  jla.invokeFinalize(finalizee); finalizee = null; } } catch (Throwable x) { } super.clear(); }   TODO Reference 深入理解\n"});index.add({'id':12,'href':'/docs/jvm/thread/','title':"Thread",'content':"Ubi loqui "});index.add({'id':13,'href':'/docs/java/concurrent/','title':"并发",'content':"缓存一致性协议（MESI，MSI，MOSI，。。。）   cache line：64Byte，一次读取64Byte到缓存。 将每一个 cache line 标记为四种状态: Modified、Exclusive、Shared、Invalid，(MESI)。MESI的实现即是CPU们对这四种状态的协调处理 伪共享 缓存行对齐   "});index.add({'id':14,'href':'/posts/','title':"Blog",'content':""});index.add({'id':15,'href':'/posts/wangfugui/','title':"Wangfugui",'content':"难得的一次抓拍合影， 第一次献给王富贵。\n"});index.add({'id':16,'href':'/docs/','title':"Docs",'content':""});})();